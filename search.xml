<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HDBSCAN</title>
    <url>/2024/12/11/HDBSCAN/</url>
    <content><![CDATA[<h2 id="1-HDBSCAN算法简介"><a href="#1-HDBSCAN算法简介" class="headerlink" title="1.HDBSCAN算法简介"></a>1.HDBSCAN算法简介</h2><p>DBSCAN(Hierarchical Density-Based Spatial Clustering of Applications with Noise)是一种高效的密度聚类算法,由Campello、Moulavi和Sander于2013年提出。它是DBSCAN算法的扩展版本,通过将DBSCAN转化为层次聚类算法,并使用基于聚类稳定性的技术来提取平面聚类结果，其实HDBSCAN算法是对OPTICS算法的一种改进。</p>
<ul>
<li>HDBSCAN算法优势：</li>
</ul>
<ol>
<li>能够发现任意形状的聚类</li>
<li>可以处理不同密度的数据分布</li>
<li>对噪声和异常值具有较强的鲁棒性</li>
<li>参数调整简单直观</li>
</ol>
<ul>
<li>HDBSCAN算法的具体过程分为一下几步</li>
</ul>
<ol>
<li>空间变换</li>
<li>构建最小生成树</li>
<li>构建聚类层次结构</li>
<li>压缩聚类树</li>
<li>提取簇</li>
</ol>
<h2 id="2-空间变换"><a href="#2-空间变换" class="headerlink" title="2.空间变换"></a>2.空间变换</h2><ul>
<li><strong>核心距离（core-distance）</strong>：使样本x成为核心点的最小邻域半径称为x的核心距离</li>
<li><strong>互达距离</strong>：</li>
</ul>
<p>$$<br>d_{mreach − k} ( a ,  b ) &#x3D; max { core_k(a),core_k(b),d(a,b)}<br>$$</p>
<p><strong>在这个度量下，密集点（具有低核心距离）之间的距离保持不变，但稀疏的点与其他点的距离被拉远到用core距离来计算。</strong></p>
<p><img src="/HDBSCAN1.png" alt="ima"></p>
<p>蓝点和绿点的互达距离，就是绿点的核心距离（绿线）</p>
<p><img src="/HDBSCAN2.png" alt="../images/HDBSCAN2.png"></p>
<p>红点和绿点的互达距离，就是他们两个点之间的距离（黄线）</p>
<h2 id="3-建立最小生成树"><a href="#3-建立最小生成树" class="headerlink" title="3.建立最小生成树"></a>3.建立最小生成树</h2><p>距离度量： <strong>互达距离</strong> </p>
<p>可将数据看作一个加权图，其中数据点为顶点，任意两点之间的边的权重为这些点之间的互达距离。考虑一个距离阈值，从高开始逐步降低，删除任何超过阈值的边，对图像进行分裂。最终图的变化过程：从完全连接到不完全连接。逐步减小阈值去分裂图的方法时间复杂度较高。正确的做法是找一个最小边集合，这样从集合中删除任何边都会导致图分裂。这个最小边的集合就是图的最小树。可以通过 <a href="https://blog.csdn.net/ACM_hades/article/details/79029253">Prim 算法</a> 非常有效地构建最小生成树树，如下图所示：</p>
<p><img src="/HDBSCAN3.png" alt="../images/HDBSCAN3.png"></p>
<h2 id="4-构建聚类层次结构"><a href="#4-构建聚类层次结构" class="headerlink" title="4.构建聚类层次结构"></a>4.构建聚类层次结构</h2><p>给定最小生成树，下一步是将其转换为图分裂的层次结构</p>
<ol>
<li>第一步：将树中的所有边按照距离递增排序</li>
<li>第二步：然后依次选取每条边，将边的链接的两个子图进行合并。（类似于层次聚类的思路）</li>
</ol>
<p>以下得到的树又称为聚类树，此时如果和层次聚类一样，设置一条distance的阈值，就可以将红线下面最近的节点作为聚类的一个类，而红线上面的聚起来的都是散点。如何得到阈值？？</p>
<p>但是这样得到的聚类结果，会有很多有很少量节点的簇，我们需要压缩聚类树。</p>
<p><img src="/HDBSCAN4.png" alt="../images/HDBSCAN4.png"></p>
<p><img src="/HDBSCAN5.png" alt="../images/HDBSCAN5.png"></p>
<p>上图是一个二叉树结构，每个节点代表的是一个样本子集，最上面的根节点代表的是所有样本点，每个节点的两条边代表的是当前节点的分裂，每次分裂都是去掉最小生成树的一边，从上到下，相当于选择最大的边进行分裂，每次分裂都对应着一个距离。</p>
<h2 id="5-压缩聚类树"><a href="#5-压缩聚类树" class="headerlink" title="5.压缩聚类树"></a>5.<strong>压缩聚类树</strong></h2><p>通过压缩聚类树，我们可以得到一棵<strong>拥有少量节点的聚类树（如上）</strong></p>
<p>簇抽取的第一步是将庞大而复杂的聚类树压缩到一个更小的树中，其实质就是去掉散点。</p>
<p><strong>最小簇大小：每个簇中样本数的最小值，作为HDBSCAN的一个参数</strong></p>
<p>压缩聚类树步骤：</p>
<ul>
<li><p>第一步：确定最小簇大小；</p>
</li>
<li><p>第二步：自上而下遍历聚类树，并在每个节点分裂时，看分裂产生的两个样本子集的样本数是否大于最小簇大小</p>
<ul>
<li>如果左右子节点有一个子节点的样本数少于最小簇大小，我们将直接将该节点删除，并且另一个子节点保留父节点的身份；</li>
<li>如果两个子节点中的样本数均小于最小簇大小，那么将其两个子节点都删除，即当前节点不再向下分裂</li>
<li>如果两个子节点的样本数均大于最小簇大小，则进行正常分裂，保持原聚类树不变。</li>
</ul>
<p>  <strong>（删除的点都是HDBSCAN视为的噪点）</strong>
  </p>
</li>
<li><p>在遍历了整个聚类树之后，我们最终得到了一个 <strong>拥有少量节点的聚类树</strong></p>
</li>
</ul>
<p><img src="/HDBSCAN6.png" alt="../images/HDBSCAN6.png"></p>
<p>用线的宽度来表示簇中的点数。由于有节点的删除宽度随逐渐变小</p>
<p>图中 λ 为距离的倒数，即：</p>
<p>$$<br>λ&#x3D;1&#x2F;distance<br>$$</p>
<h2 id="6-提取簇"><a href="#6-提取簇" class="headerlink" title="6.提取簇"></a>6.<strong>提取簇</strong></h2><p>从压缩的聚类树种提取聚类的簇，为压缩聚类树的每个节点打上一个类标签</p>
<p>提取簇的一个原则是：某个节点属于某一个簇，那么他的子节点都属于这个簇</p>
<ul>
<li><p>经过聚类树的压缩操作，树中已经没有了散点，现在的任务只是将比较相近的节点合并到一簇中去，最后选择的簇能够有更好的 <strong>稳定性。</strong></p>
</li>
<li><p>如何来定义树中节点的稳定性呢？</p>
<ul>
<li>先定义一个 λ  ，它是距离的倒数：$λ&#x3D;1&#x2F;distance$</li>
<li>对于树中的某个节点定义两个量： $λ_ {b i r t h}$ ，$λ_{death}$<br>  $λ_ {b i r t h}$ ：分裂产生当前节点时，对应断开边长度的倒数。<br>  $λ_{death}$：当前节点被分裂成两个子结点时，对应断开边长度的倒数。<br>  根据定义有:  $λ_{birth} &lt; λ_{death}$</li>
<li>对于每个节点中每个样本点 $p$ 定义一个量$λ_p$<br>  $λ_p$ 表示：样本点 $p$ 因为分裂离开该节点时，对应断开边长度的倒数。当前节点分裂使得样本 $p$ 离开当前节点有两种情况：<ul>
<li>当前节点分裂出的右儿子中有一个子结点的样本数少于最小族大小，这时我们是直间将该节点删除，并且另一个子节点保留父节点的身份，而并且样本 $p$ 在被删掉的子结点中，即样本 $p$ 是散点，这时 $λ_{birth}&lt;λ_p &lt; λ_{death}$</li>
<li>当前节点分裂出的两个子结点中的样本数都大于最小族大小，这时我们进行正常分裂，这样样本 p p <em>p</em> 进入当前节点的一个子结点。$λ_p &#x3D; λ_{death}$</li>
</ul>
</li>
<li>现在我们将每个 <strong>节点的稳定性</strong> 定义为：</li>
</ul>
<p>  $$<br>   s_{c l u s t e r}  &#x3D;   \sum\limits_{p \in \text{cluster}} (\lambda_p - \lambda_{\text{death}})</p>
<p>  $$</p>
<p>  稳定性越大说明该节点中的散点越少。hdbscan需要找到最大$\sum\limits_{p \in \text{cluster}} (\lambda_p - \lambda_{\text{death}})$的分裂簇方法，同时需要满足最小簇类大小。</p>
</li>
</ul>
<p><strong>提取簇步骤</strong>：</p>
<ul>
<li><strong>第一步</strong> ：初始化族<ul>
<li>将压缩聚类树的每个叶节点都选定为某个簇。</li>
</ul>
</li>
<li><strong>第二步</strong> ： <strong>自下而上遍历遍历整棵树</strong> ，并且每一步进行下面操作：<ul>
<li>如果当前节点的稳定性小于两个子结点的稳定性总和，那么我们将该节点的稳定性设置为其子节点的稳定性之和</li>
<li><strong>如果当前节点的稳定性大于两个子结点的稳定性总和，那么将当前节点定为某个簇，并且删除所有子节点。</strong></li>
</ul>
</li>
<li>我们可以通过这个算法选择上面压缩聚类树的聚类，得到下面结果：</li>
</ul>
<p><img src="/HDBSCAN7.png" alt="../images/HDBSCAN7.png"></p>
<p>不同颜色的圈表示不同的族，上图将样本分为三个簇。</p>
<p>我们将聚类产生的散点(即压缩聚类树时删除的节点)标为-1类，</p>
<p>相比DBSCAN算法HDBSCAN主要做了如下几个优化：</p>
<ol>
<li>定义了一种衡量两个点互相间的距离的方式（<strong>互达距离）</strong></li>
<li>使用最小生成树构建点与点之间的层次数模型，引入<a href="https://zhida.zhihu.com/search?content_id=102517831&content_type=Article&match_order=1&q=%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB&zhida_source=entity">层次聚类</a>思想，同时对最小生成树剪枝的最小子树做了限制，主要是为了控制生成的类簇不要过小</li>
<li>定义了一种叫stability的分裂度量方式，hdbscan需要找到最大$\sum\limits_{p \in \text{cluster}} (\lambda_p - \lambda_{\text{death}})$的分裂簇方法，同时需要满足最小簇类大小。</li>
</ol>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Vcpkg 安装 OSGEarth</title>
    <url>/2024/10/18/InstallOSGEarth/</url>
    <content><![CDATA[<h2 id="OSGEarth的安装"><a href="#OSGEarth的安装" class="headerlink" title="OSGEarth的安装"></a>OSGEarth的安装</h2><p>根据能查到的博客及相关教程，分两大类方法。</p>
<ol>
<li>CMake 编译方法</li>
<li>vcpkg 安装方法</li>
</ol>
<p>笔者在使用CMake编译方法遇到了大量的问题，使用VS编译时因为第三方库的问题，始终未能成功实现编译。在花费大量的时间后，转头使用vcpkg方法完成OSGEarth及其依赖项的安装。故在此进行记录安装过程，方便后续使用。</p>
<h2 id="1-安装vcpkg"><a href="#1-安装vcpkg" class="headerlink" title="1. 安装vcpkg"></a>1. 安装vcpkg</h2><p>首先，下载vcpkg并执行 bootstrap.bat 脚本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/microsoft/vcpkg</span><br><span class="line">.\vcpkg\bootstrap-vcpkg.bat</span><br></pre></td></tr></table></figure>

<p>vcpkg 的安装命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;vcpkg install [packages to install]</span><br></pre></td></tr></table></figure>

<p>若您希望在 Visual Studio 中使用vcpkg，请运行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vcpkg integrate install</span><br></pre></td></tr></table></figure>

<h2 id="2-使用vcpkg安装OSGEarth"><a href="#2-使用vcpkg安装OSGEarth" class="headerlink" title="2.使用vcpkg安装OSGEarth"></a>2.使用vcpkg安装OSGEarth</h2><p>在使用vcpkg install OSGEarth 前，确保开启GL3编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; [vcpkg安装目录]vcpkg\ports\osg\portfile.cmake 中</span><br><span class="line"><span class="keyword">if</span>(NOT DEFINED osg_OPENGL_PROFILEGL3)</span><br><span class="line">        <span class="built_in">set</span>(osg_OPENGL_PROFILEGL3 <span class="string">&quot;GL2&quot;</span>) //这里的GL2改为GL3</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>

<p>在vcpkg的根目录中以打开CMD，并输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vcpkg install osgearth:x64-windows</span><br></pre></td></tr></table></figure>

<p>即可完成安装，是的，只要这一行指令就可以完成安装，相比之下，CMake简直是让人吐血。vcpkg 安装OSGEarth时，会自动安装OSGEarth所需的各种依赖项。</p>
<h2 id="3-安装过程中的问题"><a href="#3-安装过程中的问题" class="headerlink" title="3.安装过程中的问题"></a>3.安装过程中的问题</h2><p>安装依赖项时，vcpkg会先查看downloads目录，没有的话会从Github上下载包。</p>
<p><img src="/../images/Install1.png" alt="t"></p>
<p>在从Github上下载时会面临连接不上或者下载失败等情况，这种情况下，可以找到手动点击下载链接，将下好的包命名为目标名称。举个例子：</p>
<p><img src="/../images/Install2.png" alt="t"></p>
<p>点击图中链接，保存到vcpkg下的download目录，命名为win_flex_bison-2.5.25.zip，我手动下了好几个包，一般目标名称会多一些前缀。有一些比较大的包，下载时间会比较久，要是等不及的话，也可以手动下载，不过需要重新开始指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vcpkg install osgearth:x64-windows</span><br></pre></td></tr></table></figure>

<p>经过漫长的等待之后，OSGEarth就安装完毕了。</p>
<h2 id="4-安装完毕后"><a href="#4-安装完毕后" class="headerlink" title="4. 安装完毕后"></a>4. 安装完毕后</h2><p>在编译成功后，在cmd中输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vcpkg integrate install</span><br></pre></td></tr></table></figure>

<p>将vcpkg中安装的bin加入到环境变量中：</p>
<p><img src="/../images/Install3.png" alt="t"></p>
<h2 id="5-测试用例"><a href="#5-测试用例" class="headerlink" title="5.测试用例"></a>5.测试用例</h2> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;osgEarth/MapNode&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;osgEarth/TMS&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;osgEarth/EarthManipulator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;osg/ArgumentParser&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;osgViewer/Viewer&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    osgEarth::<span class="built_in">initialize</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">osg::ArgumentParser <span class="title">args</span><span class="params">(&amp;argc, argv)</span></span>;</span><br><span class="line">    <span class="function">osgViewer::Viewer <span class="title">viewer</span><span class="params">(args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> imagery = <span class="keyword">new</span> osgEarth::<span class="built_in">TMSImageLayer</span>();</span><br><span class="line">    imagery-&gt;<span class="built_in">setURL</span>(<span class="string">&quot;https://readymap.org/readymap/tiles/1.0.0/7/&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> mapNode = <span class="keyword">new</span> osgEarth::<span class="built_in">MapNode</span>();</span><br><span class="line">    mapNode-&gt;<span class="built_in">getMap</span>()-&gt;<span class="built_in">addLayer</span>(imagery);</span><br><span class="line"></span><br><span class="line">    viewer.<span class="built_in">setSceneData</span>(mapNode);</span><br><span class="line">    viewer.<span class="built_in">setCameraManipulator</span>(<span class="keyword">new</span> osgEarth::<span class="built_in">EarthManipulator</span>(args));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> viewer.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于gl.h的问题，需要加入预处理器WIN32</p>
<p><img src="/../images/Install4.png" alt="t"></p>
<p> 发现出现了以下的问题：</p>
<p><img src="/../images/Install5.png" alt="t"></p>
<p>这是由于一些动态链接库并没有被导入bin中</p>
<p>将下列所有的dll文件移动到你的工程文件所对应的release目录中，注意如果使用debug进行调试,需要将vcpkg中debug目录下的dll和pdb文件移动到对应debug目录中。</p>
<p><img src="/../images/Install6.png" alt="t"></p>
<p>最后成功运行：</p>
<p><img src="/../images/Install7.png" alt="t"></p>
<p>完结散花，欧耶！</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>建议使用vcpkg一步到位，CMake太折磨人了，对我来说。。。。我花了很久的时间，完成最终的安装，有点儿吐血。</p>
<p>后续有必要的话，可以下载OSGEarth源码进行学习。</p>
<h2 id="7-参考链接"><a href="#7-参考链接" class="headerlink" title="7. 参考链接"></a>7. 参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/720367150">2024 - osgEarth+vs2022最新环境配置</a><br><a href="https://huangwang.github.io/2021/07/28/Windows%E4%B8%8BOsgEarth%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/">Windows下OsgEarth编译安装过程</a><br><a href="https://docs.osgearth.org/en/latest/install.html">Getting started with osgEarth</a><br><a href="https://blog.csdn.net/m0_61776040/article/details/138897125">使用vcpkg安装osg、osgearth、osgQt</a><br><a href="https://blog.csdn.net/m0_61776040/article/details/138126419">使用cmake和vcpkg构建最新osgearth3.5</a><br><a href="https://blog.songjiahao.com/archives/1067">vcpkg安装库的导出和使用</a></p>
]]></content>
      <categories>
        <category>OSGEarth</category>
      </categories>
  </entry>
  <entry>
    <title>问题记录</title>
    <url>/2024/10/28/errors/</url>
    <content><![CDATA[<h2 id="1-osgearth-ttf-file-not-handled"><a href="#1-osgearth-ttf-file-not-handled" class="headerlink" title="1. osgearth .ttf: file not handled"></a>1. osgearth .ttf: file not handled</h2><p>在使用osgearth时，发生错误如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Error</span> reading file <span class="attr">C</span>:<span class="regexp">/WINDOWS/</span>fonts\<span class="title class_">CascadiaCode</span>.<span class="property">ttf</span>: file not handled</span><br></pre></td></tr></table></figure>

<p>经查阅可知，osg的读写字体文件的插件dll找不到了。<br><strong>解决方法</strong></p>
<ol>
<li>添加环境变量<br>在系统环境变量中添加osg 的path路径</li>
<li>添加配置文件<br>在每个osg工程中配置osg头文件lib和dll以及plugins<br><img src="/../images/errorConf.png" alt="t"></li>
</ol>
]]></content>
  </entry>
</search>
